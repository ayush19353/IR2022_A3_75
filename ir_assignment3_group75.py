# -*- coding: utf-8 -*-
"""IR_Assignment3_Group75.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ao--dUAPuOf8IE2gHvT6_xJlyfhiH5iH
"""



"""***Question 1***
Link Analysis

Pick a real-world network dataset (with number of nodes > 100) from here.
[2 points] Represent the network in terms of its ‘adjacency matrix’ as well as ‘edge list’.
[28 points] Briefly describe the dataset chosen and report the following:
1. Number of Nodes
2. Number of Edges
3. Avg In-degree
4. Avg. Out-Degree
5. Node with Max In-degree
6. Node with Max out-degree
7. The density of the network
Further, perform the following tasks:
1. [5 points] Plot degree distribution of the network (in case of a directed graph, plot in-degree and
out-degree separately).
2. [10 points] Calculate the local clustering coefficient of each node and plot the clustering-coefficient
distribution of the network.
"""

# Libraries

import csv
import cv2
# from google.colab import files
# !pip install nltk
# !pip install pandas
# !pip install numpy
# !pip install ipython-autotime
# from natsort import natsorted
import string
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import style

# from google.colab.patches import cv2_imshow
from google.colab import drive
drive.mount('/content/drive')

#Importing dataset
import pandas as p
data= p.read_csv("/content/drive/MyDrive/IR_assignment3_data/Wiki-Vote.txt",sep="\t")

data.head()

# Making list of source and destination nodes and edges
list_edges=[]
node1_l=[]
node2_l=[]
for k in range(0,len(data)):
  from_node=(data['FromNodeId'][k])

  node1_l.append(data['FromNodeId'][k])
  to_node= (data['ToNodeId'][k])

  node2_l.append(data['ToNodeId'][k])
  list_edges.append((from_node,to_node))

# Converting the lists of unique nodes into np arrays
x1=np.array(node1_l)
x2= np.unique(x1)
y1=np.array(node2_l)
y2= np.unique(y1)

# Making a list containing all nodes 
fin_nodes=set(x2.tolist()) | set(y2.tolist())

type(fin_nodes)

len(fin_nodes)

graph_adjacency_list={}     # Dictionary where key is the source node and its value is list of nodes where an edge starting from the current node ends
graph_dest_list={}          # Dictionary where key is the destination node and its value is list of nodes where an edge ending at the current node starts
for i in range(0,len(list_edges)):
  x1=list_edges[i]
  source=x1[0]
  destination=x1[1]
  if destination in graph_dest_list:
    graph_dest_list[destination].append(source)
  else:
    graph_dest_list[destination]=[source]
  if source in graph_adjacency_list:
    graph_adjacency_list[source].append(destination)
  else:
    graph_adjacency_list[source]=[destination]

print(graph_adjacency_list) # adjcency list

# Creating the adjacency matrix
adjacency_matrix = np.zeros((max(fin_nodes)+1,max(fin_nodes)+1) , dtype=np.int64)# adjcacency matrix
for i in range(0,len(list_edges)): 
  x1=list_edges[i]
  source=x1[0]
  destination=x1[1] 
  adjacency_matrix[source][destination] = 1

print(len(adjacency_matrix))

print("NO. of nodes are  ",len(fin_nodes) )

print("No. of edges are  ", len(data))

print("Avg In-degree - ", len(data)/len(fin_nodes))

print("Avg out-degree - ", len(data)/len(fin_nodes))

print("max in degree", max(np.sum(adjacency_matrix,axis=0)), " Node:",(np.where(np.sum(adjacency_matrix,axis=0)==np.amax(np.sum(adjacency_matrix,axis=0)))[0][0]))

print("max out degree", max(np.sum(adjacency_matrix,axis=1)), " Node:",(np.where(np.sum(adjacency_matrix,axis=1)==np.amax(np.sum(adjacency_matrix,axis=1)))[0][0]))

print("The density is",len(data)/((len(fin_nodes)-1)*len(fin_nodes)) )

# Calculating in degree, out degree, and average and maximum degrees
in_degree_tot={}
out_degree_tot={}
in_degree_average=0
out_degree_average=0
max_indegree= -5
max_outdegree=-5
max_indegree_node=-4
max_outdegree_node=-4
for node1 in fin_nodes:
  tot_incount=0
  tot_outcount=0
  for k in graph_adjacency_list:
    if node1 in graph_adjacency_list[k]:
      tot_incount=tot_incount+1
  for k in graph_adjacency_list:
        if node1==k:
            for z in graph_adjacency_list[k]:
              tot_outcount=tot_outcount+1
  in_degree_tot[node1]=tot_incount
  out_degree_tot[node1]=tot_outcount
  if(tot_incount> max_indegree):
    max_indegree=tot_incount
    max_indegree_node= node1
  if(tot_outcount> max_outdegree):
    max_outdegree=tot_outcount
    max_outdegree_node= node1
        
  in_degree_average=in_degree_average+tot_incount
  out_degree_average=out_degree_average+tot_outcount
in_degree_average=((float)(in_degree_average))/(float)(len(fin_nodes))
out_degree_average=((float)(out_degree_average))/(float)(len(fin_nodes))

print(in_degree_average)   # indegree average

"""[5 points] Plot degree distribution of the network (in case of a directed graph, plot in-degree and
out-degree separately).
"""

print(out_degree_average) # out_degree_average

print("max in--degree", max_indegree, " is of  node",max_indegree_node)

print("max out--degree", max_outdegree, " is of  node",max_outdegree_node)

"""In degree"""

len1=len(fin_nodes)
deg_in=[]
g1=graph_dest_list.items()
print(g1)
for kf in g1:
  deg_in.append(len((kf[1])))
u1,c1=np.unique(deg_in,return_counts=True)
c1=c1.astype(float)
h=0
while(h< len(c1)):
  c1[h]=c1[h]/len1
  h=h+1;

c1

# Plot for in degree distribution
plt.plot(u1, c1, color ='g')
plt.xlabel("indegree")
plt.ylabel("tot count")
plt.title("in degree vs. count of total nodes")

# Scatter plot for in degree distribution
plt.scatter(u1, c1, color = 'g')
plt.xlabel("indegree")
plt.ylabel("tot count")
plt.title("in degree vs. count of total nodes")

# bar plot
plt.bar(u1, c1, color ='g', width=10)
plt.xlabel("indegree")
plt.ylabel("tot count")
plt.title("in degree vs. count of total nodes")

"""Out degree"""

len1=len(fin_nodes)
deg_in=[]
g1=graph_adjacency_list.items()
print(g1)
for kf in g1:
  deg_in.append(len((kf[1])))
u1,c1=np.unique(deg_in,return_counts=True)
c1=c1.astype(float)
h=0
while(h< len(c1)):
  c1[h]=c1[h]/len1
  h=h+1;
c1

# Plot for out degree distribution
plt.plot(u1, c1, color ='g')
plt.xlabel("outdegree")
plt.ylabel("tot count")
plt.title("out degree vs. count of total nodes")

# Scatter plot
plt.scatter(u1, c1, color = 'g')
plt.xlabel("outdegree")
plt.ylabel("tot count")
plt.title("out degree vs. count of total nodes")

# Bar plot
plt.bar(u1, c1, color = 'g',width=20)
plt.xlabel("outdegree")
plt.ylabel("tot count")
plt.title("out degree vs. count of total nodes")

"""2. [10 points] Calculate the local clustering coefficient of each node and plot the clustering-coefficient
distribution of the network.
"""











"""2. [10 points] Calculate the local clustering coefficient of each node and plot the clustering-coefficient
distribution of the network.
"""

# Function to find all the unique neighbour nodes
def getneigbours(n1,n2):
  return np.where(n2[n1]>0)[0]

# undirected part
C2={}
# Creating another adjacency matrix where the graph is considered to be un directed
graph_new_adjacency_matrix=np.zeros((max(fin_nodes)+1, max(fin_nodes)+1),dtype=np.int64)
for i in range(0,len(list_edges)):
  x1=list_edges[i]
  source=x1[0]
  destination=x1[1] 
  graph_new_adjacency_matrix[source][destination]=1
  graph_new_adjacency_matrix[destination][source]=1
array_graph_matrix=np.array(graph_new_adjacency_matrix)

# finding the clustering coefficient
for i in fin_nodes:
  nodep=i
  coeff=0
  neibours= getneigbours(nodep,array_graph_matrix)
  if(len(neibours)!=1):
    for neibour1 in neibours:
      for neibour2 in neibours:
        if(neibour1 != neibour2):
          if(array_graph_matrix[neibour1][neibour2]==1):
            coeff=coeff+1
        else:
          continue
    coeff=coeff/2
    coeff=coeff/ (len(neibours)*(len(neibours)-1)/2)
    C2[nodep]=coeff
        
  else:
    C2[nodep]=coeff
    continue
print(C2)



D1= C2.values()
tot_di= np.array(list(D1))
u11, c11= np.unique(np.array(list(D1)),return_counts=True)
c11= c11.astype(float)

# Plotting Clustering coefficient distribution
style.use('ggplot')
plt.figure(figsize=(15, 8), dpi=80)
plt.plot(u11[1:],c11[1:],color ='b',linewidth = 2)
plt.title('cluster coefficient line geaph')
plt.xlabel('local clustering coefficent')
plt.ylabel('count of the nodes')
plt.show()

# Bar Plot
from matplotlib import style

style.use('ggplot')
plt.figure(figsize=(15, 8), dpi=80)
plt.bar(u11[1:],c11[1:],color ='b',width = 0.02)
plt.title('cluster coefficient bar geaph')
plt.xlabel('local clustering coefficent')
plt.ylabel('count of the nodes')
plt.show()

# Scatter Plot
from matplotlib import style

style.use('ggplot')
plt.figure(figsize=(15, 8), dpi=80)
plt.scatter(u11[1:],c11[1:],color ='b',)
plt.title('cluster coefficient scatter geaph')
plt.xlabel('local clustering coefficent')
plt.ylabel('count of the nodes')
plt.show()





"""Question 2 - [35 points] PageRank, Hubs and Authority
For the dataset chosen in the above question, calculate the following:
1. [15 points] PageRank score for each node
2. [15 points] Authority and Hub score for each node
[5 points] Compare the results obtained from both the algorithms in parts 1 and 2 based on the node
scores.
"""

# Creating a digraph
import networkx as nt
digraph1 = nt.DiGraph()
digraph1.add_nodes_from(fin_nodes)

digraph1.add_edges_from(list_edges)

print(digraph1.nodes)

# Calculating the page rank values
page_rank=nt.pagerank(digraph1,alpha=0.8)
page_rank

page_rank1=nt.pagerank(digraph1,alpha=0.9)
page_rank1

# Calculating the hubs and authority scores using hits algo
hubs,auth=nt.hits(digraph1)

print(hubs)

print(auth)

import networkx as nt
digraph = nt.DiGraph()
digraph.add_nodes_from(fin_nodes)

digraph.add_edges_from(list_edges)

# Clustering the digraph
nt.clustering(digraph)

z1= sorted(hubs.items(), key=lambda x: x[1], reverse=True)
z2=sorted(auth.items(), key=lambda x: x[1], reverse=True)

high_hub=[]
high_hub1=[]
for i in range(0,20): # top 20 highest hubs values with nodes
  high_hub.append(z1[i])
  high_hub1.append(z1[i][0])
print(high_hub)

high_auth=[]
high_auth1=[]
for i in range(0,20): # top 20 highest authority values with nodes
  high_auth.append(z2[i])
  high_auth1.append(z2[i][0])
print(high_auth)

z3= sorted(page_rank.items(), key=lambda x: x[1], reverse=True)
high_page=[]
high_page1=[]
for i in range(0,20): # top 20 page rank nodes with values 
  high_page.append(z3[i])
  high_page1.append(z3[i][0])
print(high_page)

print(high_page1)

def common_member(a, b):   
    a_set = set(a)
    b_set = set(b)
     
    # check length
    if len(a_set.intersection(b_set)) > 0:
        return(a_set.intersection(b_set))

print(common_member(high_auth1,high_page1))

print(common_member(high_auth1,high_hub1))

print(common_member(high_hub1,high_page1))

